# 问题总结



# MySQL

### 索引优化

- 需要进行排序或者分组的字段可以建立索引
- 需要用做条件查询的字段可以建立索引
- 尽量建立联合索引而不是建立多个普通索引
- 写sql语句时尽量满足最左匹配原则
- 避免使用函数或者对查询字段进行表达式运算，会导致索引失效
- 尽量减少范围查询

### 索引失效



### 如何针对一条SQL语句进行优化

- 使用小表驱动大表 ==使用小表的数据集驱动大表的数据集==

- 多表查询的时候尽量使用连接查询而不是子查询 ==连接查询需要创建临时表，查询完毕后，需要删除临时表==
- 使用``explain``执行计划查看索引使用情况，如果没有使用索引，看是没有建立索引还是建立了但是没用使用到。如果没有建立索引就去建立索引，如果建立了索引，就修改SQL语句，让SQL语句使用到我们需要用到的索引。在修改的时候要遵循最左匹配原则。尽量少使用范围查询和模糊查询。查询的时候只查询索引字段，减少回表操作。

​	

### 事务的四大特性

**ACID：原子性，一致性，隔离性，持久性。**

- 原子性：一个事务里的操作，要么全部成功，要么全部失败。 ==undolog实现==
- 一致性：执行事务前后，数据保持一致。
- 隔离性：并发访问数据库的时候，一个用户的事务不被其他事务所干扰，各并发事务之间的数据是独立的。 ==通过MVCC来实现==
- 持久性：事务处理结束后，对数据的修改时永久的，即使是系统宕机也不会丢失。 ==redolog日志实现==



### 数据库的隔离级别

**读未提交，读已提交，可重复读，串行化**

- 读未提交：能够读取到其他事务没有提交的数据。会发生脏读、幻读、不可重复读。
- 读已提交：能够读取其他事务已经提交的数据，解决了脏读，但是会发生不可重复读和幻读。
- 可重复读：一个事务多次读取数据库，读到的数据都是一样的，解决了脏读和不可重复读，会发生幻读。在Mysql中，使用mvcc在可重复读的隔离级别下解决了幻读。
- 串行化：让多个事务依次进行，事务隔离级别最高，安全性最好，但是效率最低。

### MyISAM和Innodb的区别

- innodb支持事务，myisam不支持事务。
- myisam只支持表级锁，innodb支持表级锁和行锁。
- innodb支持外键，myisam不支持外键。

- myisam有一个记录行数的变量，在获取行数的时候，可以直接获取这个变量；而innodb需要全表扫描统计。
- innodb的索引分为聚簇索引和非聚簇索引，主键索引是聚簇索引，其他的都是非聚簇索引；而myisam只有非聚簇索引。==myisam的索引和数据文件是分离的，两者都是用b+树作为索引的数据结构。 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。==
- innodb必须有主键，如果自己没有设置的话，会使用一个隐藏的row_id作为主键。



### 为什么innodb没有使用一个变量来记录行数

因为innodb支持事务，多个事务看到的数据是不一样的，他们的记录行数也是不一样的。所以没有使用一个变量来记录行数，而是使用count函数来统计当前事务的记录数。



### InnoDB为什么推荐使用自增ID作为主键？

在innodb中，数据是直接存储在主键索引对应的叶子节点中。如果主键是有序的，那么插入数据的时候只需要将这条数据插入到最后一条记录的后面即可。

而如果主键是随机的，那么在插入数据的时候，就无法简单的将数据插入到最后，而是需要先找到合适的位置再进行插入，这样就会产生大量的页分裂并且会移动大量的数据，影响效率。**如果目标页不在内存中，就会导致大量的随机io。**



### 说说mvcc多版本并发控制











# JAVA基础

### 怎么重写hashcode和equals方法

equals方法：首先使用``==``判断两个对象是否相等，如果相等直接返回true；其次使用instanceof()判断是否是同一个类型的，如果不是直接返回false。接着使用各个属性的类型的equals方法来进行判断。两个对象对应的属性的值是否相等。返回判断值。

hashcode方法：调用每个属性对应的hashcode方法计算出一个hashcode值，然后使用这个hashcode值加上当前值*31，用这个值作为当前值，依次调用，最后会得到一个值，这个值就是这个对象的hashcode值。

- hashcode值相等，equals不一定相等。
- hashcode不相等，equals一定不相等。
- equals相等，hashcode一定相等。
- equals不相等，hashcode可能相等。

之所以使用hashcode，是为了提高效率。在进行比较的时候，首先计算两个对象的hashcode值是否相等，如果两个对象的hashcode都不相等的话，那么两个对象一定不相等，所以没必要使用equals进行判断；当两个hashcode相等的情况下再使用equals进行判断。能够减少equals的频率。

### 文件输入输出，javaIO使用了什么设计模式



### static修饰的作用



### LinkedHashMap



### 接口和抽象类





### 乐观锁的具体实现







### StringBuffer是如何实现线程安全的

StringBuilder和StringBuffer都是可变对象。

StringBuffer是在JDK1.0就有了，StringBuilder在JDK1.5才出现。StringBuilder是为了解决StringBuffer效率低而出现的。

StringBuffer底层加了``Synchronized``锁，保证线程安全，但是由于加了锁，加锁解锁需要消耗一部分性能，因此效率比较低。

StringBuilder是线程不安全的，但是效率高。因此单线程推荐使用StringBuilder，多线程使用StringBuffer。







# JVM

### 说说垃圾回收





### 什么时候会进行垃圾回收







### 类加载的过程

首先会将编写的java代码编译成字节码文件，然后jvm会去加载字节码文件，在堆空间创建一个Class类对象。然后会检查字节码文件是否符合当前jvm的规范。接着会为程序中的静态变量分配内存并且赋初值。然后将符号引用转变为直接引用。最后才开始执行java代码，根据编写顺序依次执行静态代码的赋值语句和静态代码块中的代码。



### 类卸载的过程





### 什么是双亲委派机制

jvm提供了三种类加载器，引导类加载器，拓展类加载器，应用类加载器。

双亲委派机制是说当一个类加载器收到类加载的请求时，自己不会去加载这个类，而是将这个类交给自己的父类去加载。只有当父类不能够加载这个类的时候，才由当前类加载器进行加载。

打破双亲委派机制：继承``ClassLoader``类，实现``loadClass()``方法。

如果不想打破双亲委派机制，只是想创建一个自定义的类加载器：继承``ClassLoader``类，实现``findClass()``方法。



### 









# Redis



### redis里面放什么数据

一般来说，把经常进行查询，不经常修改，不是特别重要的数据放到redis作为缓存



### 一致性哈希







### 主从同步流程

>全量同步：master将完整内存数据生成RDB,发送RDB到slave，后续命令则记录在缓冲区，逐个发送给slave
>
>增量同步：slave提交自己的offset到master，master从缓冲区中获取offset之后的数据给slave

从机连接到主机的时候，主机会判断他是不是第一次连接,==看从机携带的replid是否和主机的replid一致，如果不一致，则是第一次连接==。

- 第一次连接master会生成RDB快照文件，然后将RDB文件发送给slave，slave清空本地数据，加载master的rdb。master会将rdb期间接收到的命令记录在缓冲区，然后将缓冲区的数据发送给slave。
- 如果不是第一次连接，并且slave结点断开不是很久==slave的offset没有被覆盖==，就会触发一次增量同步。slave提交自己的offset到master，master从缓冲区中获取offset之后的数据给slave。

什么时候执行全量同步？

- slave结点第一次连接master节点时
- slave结点断开时间太久，缓冲区的offset被覆盖

什么时候执行增量同步？

- slave结点断开又恢复，并且在缓冲区能找到offset



### 说说Redis集群

集群中有多个master，每个master保存不同数据。

每个master都可以有多个slave结点，可以做读写分离。

master之间通过ping监测彼此健康状态。

客户端请求可以访问集群任意节点，最终都会被转发到正确结点。

redis将集群分为16384个插槽，每个实例保存的插槽数量不一样，根据key的有效部分==key包含{}，则{}内的为有效值；不包含{}，整个key为有效值==使用CRC16算法计算出哈希值，对16384取余，余数作为插槽，将元素保存到对应的插槽中。

如果想要同一类数据保存在同一个实例，可以使用`{}`将共同前缀包裹起来，这样计算出来的插槽就一样了。

**优点：**

- 集群中所有主节点的内存大小即为集群的内存大小，可以存储海量数据。
- 一个主机可以有多个从机，多个主机提供写服务，提高效率。
- 当主机发生故障，会自动转移故障选择新的主机。

**缺点：**

- 如果一个主机和他的所有从机都挂掉了的话，那么这个集群将不能提供服务。



### 哨兵模式的优缺点

哨兵模式是对主从模式的优化，在主从的基础上，添加了哨兵节点，哨兵会监控所有的节点，并且会通过发送ping命令监测他们的健康状态。

如果一个实例距离最后一次有效回复ping的命令时间超过设定的值，就会被哨兵标记为主观下线。

如果一个**master**被标记为主观下线，那么其他sentinel都会来检测他，超过一定数量的sentinel认为该master主观下线后，这个master被标记为客观下线。会从他的从机里面选择一个实例作为新的主机，并且其他的从机都被挂在这个节点的下面。

**优点：**

- 读写分离，提高了效率
- 数据热备份，提供多个副本
- master宕机，自动选择新的主机，不需要人为干预，提高可用性。

**缺点：**

- 只有一个主节点对外提供写服务，如果是写多的情况则不能支持很好的并发。
- 主节点的单机存储有上限，无法存储海量数据。



### 哨兵模式选主策略

按照在线状态、网络状态筛选过滤掉一些不符合要求的从节点，如果从节点总是和主节点断开，而且断开次数超过一定的阈值，就会认为这个从节点不太稳定，筛选掉他。

然后依次按照优先级、复制进度、ID 号大小再对剩余的从节点进行打分，只要有得分最高的从节点出现，就把它选为新主节点。

- 优先级高的从节点得分高。
- 与旧主节点同步程度最接近的从节点得分高。
- ID号小的得分高。



### 讲讲对布隆过滤器的理解

> **布隆过滤器可以用于检索一个元素是否在一个集合中。**
>
> **误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。**数组越长，哈希冲突的概率越低。

**布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。**

比如将1003添加到过滤器中，首先会经过K个散列函数得到K个下标，然后将该位置置为1。当下次来查询的时候，同样通过散列函数，查看对应下标是否为1。如果有一个位置为0，则该元素一定不存在。如果全部为1，则该元素可能存在。==因为存在哈希冲突，其他元素通过散列可能会将对应位置置为1，这就是为什么布隆过滤器会有一定的误判率。==

目前布隆过滤器可以支持add和isExist操作，但是不支持delete操作。因为存在哈希冲突，可能多个值对应的位是相同的。比如user1和user2都可以映射到第四个bit位，如果我们删除user1，就会将第四个bit位置为0，这样我们查询user2的时候也会返回false，但是其实我们并没有删除掉user2。

使用``Redisson``实现分布式布隆过滤器，使用``guava``实现本地布隆过滤器。

常见的应用场景：

- 解决缓存穿透
- 爬虫过滤已抓到的url就不再抓，可用bloom filter过滤
- 垃圾邮件过滤



### setnx 和 setex 是什么作用

``setex`` 可以将value关联给key,并给key设置过期时间。

``setnx`` SET if Not eXists 当key不存在的时候可以添加成功，存在的时候添加失败。

**拓展： ``SET lock 1 EX 10 NX`` 拥有上面两条指令的功能,当lock这个key不存在时才创建成功，并且设置了过期时间（10s)。这条语句具有原子性，不会被其他打断。**



### Redis实现消息队列

1. 使用List

   使用List数据结构，一端放数据，一端取数据，可以实现消息队列的功能。可以对消息进行持久化，但是只能够单个消费，不能将消息发送个多个消费者。

2. 基于PubSub

3. 基于Stream流

   

### Redis的持久化

redis有两种持久化方式：``RDB`` 和``AOF``

``RDB``会每隔一段时间，创建一个子线程去生成RDB快照文件，这个文件包括了当前redis中的全部数据。但是由于他是每隔一段时间才会生成一次，所以如果在两次生成``RDB``的间隔内，redis宕机，那么就会损失这一段时间的数据，安全性较低。

``AOF``是在文件的末尾追加redis的每一个写指令，每隔1s会进行刷盘，就算redis宕机，最多只损失1s中的数据。因此``AOF``的安全性比较高，但是在有相同数据的情况下，``AOF``文件大小比``RDB``的文件大，而且恢复数据的时候，``AOF``的速度也比``RDB``慢。



### Redis的过期策略

- 定时删除：设置过期时间的key一旦过期，马上进行删除。 ==对内存友好，对cpu不用好==
- 惰性删除：key过期的时候不马上删除，在获取key的时候在判断key是否过期，如果过期则删除这个key。
- 定期删除：系统每隔一段时间，就对设置了过期时间的key进行一个抽样检查，如果key过期，则删除key。





# 并发编程



### 锁升级的过程

> 参考：https://www.cnblogs.com/wuqinglong/p/9945618.html

- 偏向锁升级：线程1获取到锁对象时，会在锁对象的对象头和栈帧中记录获取到锁的线程id，由于偏向锁不会主动释放锁，因此下次线程1来获取锁的时候会判断当前线程id是否和锁对象头中记录的线程id一样，如果一致则直接进行下面的操作。如果不一致（比如其他线程来获取锁），需要查看对象头中记录的锁对象是否存活，没有存活就将当前锁对象置为无锁状态，其他线程可以来获取锁；如果存活则判断是否还需要持有当前锁，如果需要，则升级为轻量级锁，不需要就将锁对象置为无锁状态，其他线程可以来获取锁。
- 轻量级锁升级：线程1获取锁轻量级锁时会把锁对象的对象头mark word复制一份到线程1的栈帧中，然后使用cas替换对象头的内容，线程2来获取锁的时候，发现线程1已经替换了对象头，线程2就会进入自旋状态，当自旋次数达到一定数量线程1还没有释放锁，就会升级为重量级锁。



### 线程的状态

> 在JAVA中，线程一共有六种状态：new、runable、blocked、wating、timewating、terminated

- new：初始状态，线程被构建，但是还没有执行start方法
- runable：运行状态，调用start方法之后，进入运行状态
- blocked：阻塞状态，获取锁失败进入阻塞状态
- wating：等待状态，调用``wait()``,``join()``等方法会进入等待状态 ==需要其他线程的通知才能够返回运行状态==
- timewating：超时等待状态，过了指定时间会自动唤醒。调用``sleep（long millis）``，``wait（long millis）``方法进入超市等待状态
- terminated：终止状态，线程执行完毕之后处于终止状态

### volatile和synchronize的区别

- volatile可以保证变量的可见性和有序性，不能够保证变量的原子性；synchronize可以保证变量的原子性、可见性、有序性。其中volatile保证有序性是可以防止指令重排，而synchronize保证有序性是因为他保证同一时间只能有一个线程访问变量，单线程的执行结果不会改变。
- volatile只能够用来修饰变量，但是synchronize可以用来修饰同步代码块还有同步方法。

- volatile可以说是synchronize的一种轻量级实现，性能会比synchronize好；volatile主要用来保证变量的可见性，synchronize主要用来保证线程间的同步性。



### sleep和wait的区别

wait()是object类的方法，因此所有的类都有wait()这个方法。wait()方法需要配合synchronize关键字使用，只能出现在synchronize修饰的同步代码块或者同步方法中。使用wait()方法后当前线程会阻塞，并且不会自动唤醒，需要其他线程使用notify()或者使用notifyAll()方法才能够唤醒线程。调用wait()方法阻塞的线程会释放掉当先线程获取的锁。

sleep()方法是Thread类的方法，可以使用在任何地方，并且会在设定的休眠时间之后自动唤醒，在休眠期间不会释放掉获取到的锁。



### 单例模式

> 懒汉式：只有用户真正需要使用的时候才会创建对象。
>
> 饿汉式：在类加载的时候就会创建对象，即使用户不需要使用到该对象。

单例模式就是保证在整个应用中只有一个类的实例存在。关键在于将构造器私有化，不对外提供构造方法。在实体类中创建出类的实例，对外提供获取类实例的方法。

其中饿汉式是天然线程安全的，因为他是在类加载的时候进行创建，不会有线程安全问题。

懒汉式不是线程安全的，可能存在线程安全问题，并且因为是在第一次调用的时候才创建实例，而且为了保证线程安全，懒汉式多一般会加同步锁。所以性能上会比饿汉式差一点。



### 双重检测锁单例模式为什么要是用volatile修饰

```java
public class Singleton {
    private volatile static Singleton singleton;

    private Singleton(){
        
    }
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

使用``volatile``修饰是因为对象的创建分为三个步骤

1. 给对象分配内存

2. 调用构造器方法，执行初始化

3. 将对象引用赋值给变量

但是jvm内部可能会出现指令重排，将2,3重排序，导致将一个未被初始化的对象赋值给变量，这时如果有另一个线程来获取对象，经过判断singleton变量已经有值了，所以直接返回这个变量，但是这个对象还没有经过初始化，是不完整的实例。而使用``volatile``修饰可以防止发生指令重排。



### 线程安全的定义？实现线程安全的方式有哪些？

当多个线程同时访问对象时，如果不用考虑线程的交替运行，也不需要进行额外的操作。调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

实现线程安全的方式：使用悲观锁，保证同一时间是有一个线程能够访问要操作的数据；其次就是使用乐观锁，在最后修改数据的时候进行判断，提高程序的并发性。



### 线程池了解吗？说一下线程池的核心参数和执行流程

频繁创建和销毁线程是一件非常消耗性能的事，使用线程池可以让我们复用创建好的线程，集中管理线程，提高程序的性能。

线程池的核心参数有：

- 核心线程数
- 最大线程数
- 工作队列
- 空闲时间： 多余空闲线程数的存活时间
- 时间单位
- 线程工厂：用于创建线程池中的线程的线程工厂
- 拒绝策略

执行流程：当线程数还没有达到核心线程数时，每提交一个任务就会创建一个线程，让线程数尽快达到核心线程数；当线程数达到核心线程数时，这是就会将提交的任务放在工作队列中，线程中工作队列中取出任务执行；当线程数达到核心线程数并且工作队列也满了的时候，就会创建一些非核心线程数来帮忙执行任务；当线程数达到最大线程数并且工作队列也满了，就会执行拒绝策略。



### 线程池的拒绝策略

- **AbortPolicy：**会丢弃最新的任务，并且会直接抛出异常。
- **DiscardPolicy：**不抛出异常，会丢弃最新的任务。
- **DiscardOldestPolicy：**不抛出异常，会丢弃工作队列中队首的任务。
- **CallerRunsPolicy：**不丢弃任务，而是调用提交任务的线程来执行任务。





# 场景题

### 有一个日志表，每天会生成很多日志信息，查询慢，如何优化

我的回答 ：

首先日志基本上是根据时间查询，可以根据时间建立一个索引，提高查询效率。面试官说可以，还有没有其他的优化方法。

我说数据量很大的话，可以进行一个分库分表。然后问具体怎么分，我说可以根据时间进行分，比如说10月1号之前的放在一张表，10月1号之后的放在另外一张表。面试官问那怎么知道该查询哪张表呢？我其实想到了说拼接一个table name。但是没敢说出来。

面试官说：

首先建立一个索引，但是实际上并不一定是按照时间查询，也可以根据日志级别进行一个查询，比如info，debug之类的。所以可以根据时间，条件进行一个查询。

分库分表的话也是一样，可以根据时间进行分表，也可以根据条件进行一个分表。然后根据前端传过来的条件拼接表名，进行查询。

还可以引入elasticsearch来进行搜索。



### 实现一个功能，用户一个小时登录错误三次，将他账号封一天

我的回答：

使用redis，用户如果密码登录错误，将他的用户名存到redis中，并设置一个小时的过期时间和计数器，如果这个该用户的计数器到了3，就将他的用户名添加到另一个字段中，设置一天的过期时间。



### 不用redis可以设置过期时间吗

如果是单机的话可以使用map来记录当前时间，下一次请求的时候用当前时间-map中记录的时间，进行判断。



### 给40亿个不重复的无符号整数，没排过序，如何快速判断一个数是否在这40亿个数中

可以使用位图，使用1bit代表一个数字，如果存在，对应位置的bit为1，否则为0。

申请2^32个bit，读入40亿个数，设置相应的bit位。读入要查询的数字，然后去查看对应bit为是0还是1。

内存占用：2^32/8/1024/1024=512MB



### 如何快速统计系统中登录的用户数量

使用redis的bitmap==位图==来实现，当用户登录的时候，以用户的id作为偏移量，将该偏移量的值设置为1；当用户退出的时候，将该用户id对应的偏移量的值设置为0。

内存占用：一个用户只占用1bit，20亿用户占用20亿个bit，也就是20亿/8/1024/1024 = 238MB。如果是使用set来存储的话，20亿内存大概占用8GB。

![image-20220607165802128](https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220607165802128.png)



### web系统的安全应该要考虑哪些方面





### token前端怎么保存能不让其他人拿到使用



### 怎么控制请求数量（1秒钟100个请求）

- 计数器
- 令牌桶
- 漏桶



### 如果存在大量的请求该怎么处理？

- 如果是大量的查询请求，可以使用Redis作为中间件，将数据缓存在redis里面，提高系统的并发。
- 可以利用MQ做流量削峰，将请求放入MQ中，依次执行。
- 还可以对接口做限流操作，比如我的接口1s只能处理10w个请求，超过10w的请求就直接返回失败。







# 框架

### springmvc的执行流程

>参考以下博客
>
>- https://blog.csdn.net/weixin_53353693/article/details/124057001
>- https://www.cnblogs.com/eneblog/p/15322338.html

- 用户发送请求到DispatcherServlet（前端控制器）。

- DispatcherServlet将请求发送给HandlerMapping，HandlerMapping会根据请求找到处理该请求的处理器，并将其封装为处理器执行链返回给DispatcherServlet
- DispatcherServlet根据处理器执行链找到能够执行该处理器的HandlerAdaptor（处理器适配器）
- HandlerAdaptor会调用具体的Controller来执行请求
- Controller处理完毕后，会返回一个封装了处理结果和要跳转的视图的对象ModelAndView 
-  DispatcherServlet将ModelAndView传给ViewReslover视图解析器
-  ViewReslover解析后返回具体View
- DispatcherServlet根据View进行渲染视图（将模型数据填充至视图中），形成响应对象 (HttpResponse)
- DispatcherServlet 响应 (HttpResponse) 给浏览器



# 计算机网络

### GET和POST请求的区别

- get是向服务器请求数据；post是向服务器提交数据。get请求具有幂等性和安全性。==安全性：不会修改服务器的数据；幂等性：多次执行方法得到的结果都一样==
- get请求的参数会直接拼接在url地址后面，post请求的参数通过request body来传递。因此post比get更加安全
- get请求的参数只能是ascii字符，并且长度有限制；post可以支持多种类型，并且没有长度限制。
- get请求会被浏览器缓存，但是post请求不会。
- get请求回退没有影响，但是post请求回退会再次提交请求。

### 中间人攻击



### 介绍下http协议



### ping操作用到了那些协议

- DNS：把域名转换为网络可以识别的ip地址
- arp：地址解析协议，根据ip地址获取mac地址
- icmp：控制报文协议，tcp/ip协议族的一个子协议，用于在ip主机、路由器之间传递控制消息（网络通不通、主机是否可达、路由是否可用等消息）

**没有使用TCP协议**



### TCP/IP网络模型

tcp/ip网络模型一共有四层：应用层、运输层、网络层、网络接口层。

应用层：应用层是我们能够直接接触到的一层，应用层只需要专注于为用户提供应用功能，会见数据向下传递给运输层。应用层常见的协议有：http、ftp（文件传输协议）、smtp（电子邮件传输协议）。

运输层：运输层会接受应用层的数据，然后将它传递给网络层。运输层有两个传输协议：Tcp和Udp，其中Tcp提供可靠的数据传输，Udp只负责发送数据，而不保证数据的完整性和安全性。如果传输层的数据长度超过mss，就会将数据包进行分段。

网络层：网络层负责将数据从一个设备传输到另一个设备。接受运输层的数据，加上ip头部组装成ip报文，然后将报文传递给网络接口层。**如果报文的长度长多了mtu的长度，也会进行分片。**

网络接口层：网络接口层负责为网络层提供链路级别传输的服务，接受ip报文，然后在头部加上mac地址封装成帧发送到网络上。



### HTTP 和 HTTPS 的区别





### HTTPS请求过程

- 客户端向服务器发起请求，请求中包含使用的TLS版本号，一个随机数，以及客户端支持的加密方法。
- 服务器收到客户端的请求后，确认双方使用的加密方法和TLS版本号，给出服务器的数字证书，以及服务器生成的一个随机数。
- 客户端收到数字证书后，会生成一个随机数，使用浏览器或操作系统中的CA公钥验证数字证书的真实性，如果证书没问题，会从数字证书中取出服务器的公钥，使用公钥加密报文。
- 服务器使用自己的私钥来解密客户端发过来的随机数，客户端和服务器使用之前协商好的加密算法，根据三个随机数生成会话秘钥，之后对话的过程都使用这个秘钥来进行加密。



### 为什么HTTPS要分别使用非对称加密和对称加密

> 对称加密：加密和解密的秘钥使用的是同一个
>
> 非对称加密：加密和解密的秘钥不是同一个，加密的是私钥，解密的是公钥，一般公钥是可以公开的，私钥是保密的。
>
> **用公钥加密的数据，只有使用对应的私钥才能解密；用私钥加密的数据，只有使用对应的公钥才能解密**

**HTTPS结合了对称加密和非对称加密，在传输数据阶段使用对称加密，对称加密的秘钥采用非对称加密来传输。**

对称加密加密速度快。但是由于秘钥也需要在网络中进行传输，如果秘钥被其他人获取到，那么整个加密过程就毫无作用了。

非对称加密加密速度慢。但是被公钥加密过的数据只能使用私钥来解密。

因此使用非对称加密来生成对称加密的秘钥，保证生成的秘钥不会被黑客锁获取，对称加密的秘钥生成完之后，所有的通信采用非对称加密。



### 对称加密和非对称加密哪个快？

对称加密比非对称加密更快，因为对称加密使用的是位运算，所以运算起来更快



### 三次握手

客户端向服务器发送一个







### 为什么使用三次握手，两次握手可以吗？

不能是两次握手。



### 四次挥手







### 为什么是挥手是四次，而握手是三次

三次握手是因为服务器接收到syn报文之后，将回复的ack报文和他自己要发送的syn报文一同发送过去，合并成一次请求。

而四次挥手是因为服务器收到客户端的请求后，回复一个ack报文，表示自己收到了他的请求，但是自己还有数据需要处理，当数据处理完之后会发送一个fin报文，表示自己数据处理完了，可以关闭连接了。







# 操作系统

### 线程和进程有什么区别

**进程是资源分配的基本单位，线程是CPU调度基本单位。**

进程是运行中的程序，当我们打开一个软件的时候，就是开启了一个进程。一个进程可以有多个线程，但是至少会有一个线程，因为进程本身就是一个线程。

线程就是进程中的一条执行流程，在java中，程序计数器、本地方法栈、虚拟机栈是每个线程私有的，而堆和方法区是所有线程共有的。线程能够减少并发执行的时间，在创建和销毁的时候，会消耗更少的资源，因此线程被称为是轻量级的进程。

### 进程间使用什么进行通信

- 匿名管道
- 有名管道
- 信号量
- 信号
- 消息队列
- 共享内存
- socket



### 进程调度算法

- 先来先服务调度算法：根据进程的先后顺序进行调度，先到就绪队列的先调度。**对长作业有利，非抢占式。**
- 最短作业优先调度算法：优先选择运行时间最短的进程进行调度。**对短作业有利，容易造成长作业饥饿，非抢占式。**
- 高响应比优先调度算法：进行进程调度的时候，先计算响应比，响应比高的线程优先调度。**计算公式：(等待时间+运行时间)/运行时间**
- 时间片轮转调度算法：每个进程分配一个时间段，线程在该时间段中运行。**非抢占式**
- 最高优先级调度算法：从就绪队列中选择最高优先级的进程进行运行。**有抢占式和非抢占式**
- 多级反馈队列调度算法：有多个队列，队列优先级从高到低，时间片逐渐增加。当一个进程时间片用完还没结束时，就会被放到下一个队列中，等待调度。如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列。**抢占式**







# Mybatis

### 插入数据的时候如何直接获取主键

在xml的insert标签中，设置useGeneratedKeys==设置为true==和keyProperty==对应实体类的主键id属性==，同时mysql的主键需要设置为自增



### xml文件中，$和 # 的区别

- ``#{}``是占位符，对应的变量会自动加上单引号，可以防止sql注入。
- ``${}``是拼接符，对应的变量不会自动加上单引号，会发生sql注入问题。



### MyBatis缓存机制

MyBatis通过缓存机制减轻数据库压力，分为一级缓存和二级缓存。

一级缓存是SqlSession级别的缓存。如果同一个SqlSession对象多次执行完全相同的SQL语句，在第一次执行完成后，MyBatis会将查询结果写入到一级缓存中，此后，如果程序没有执行插入、更新、删除操作，当第二次执行相同的查询语句时，Mybatis会直接读取一级缓存中的数据，而不会去查询数据库。==每个线程有自己的SqlSession对象==

由于每个线程有自己的SqlSession对象，因此如果多个用户来查询数据，即使中间没有进行修改操作，仍然会直接查询数据库，而不是走缓存。二级缓存就是为了解决这个问题。

二级缓存是Mapper级别的缓存==一个Mapper.xml文件被称为一个Mapper==，多个SqlSession对象共享二级缓存。多个SqlSession对象使用同一个Mapper的相同查询语句去操作数据库，在第一个SqlSession对象执行完后，MyBatis会将查询结果写入到二级缓存，此后如果程序没有执行插入、更新、删除操作，当第二个SqlSession对象执行相同的查询语句时，会直接读取二级缓存的数据。

二级缓存需要手动开启，[开启可以参考这篇博客](https://blog.csdn.net/weixin_45012575/article/details/107963575)





# Spring

### 说下你对spring ioc的理解

控制反转（IOC）是面向对象编程中的一个设计原则，用于降低程序代码之间的耦合度。

对象的创建不再由程序员使用new关键字手动创建，而是将对象注入到spring的ioc容器中，由spring的ioc容器来进行创建。控制权由应用代码转移到了IOC容器，控制权发生了反转，这就是Spring的控制反转。

**依赖注入（DI）指的是使用spring框架创建对象时，动态地将其所依赖的对象注入到Bean组件中。**



### AOP有哪些应用场景

- 日志记录
- 事务管理 ==在方法执行前开启事务，在方法结束后关闭事务==
- 监控性能 ==在方法执行的时候打印时间，在方法结束后打印时间==



### Spring为什么默认是单例的

> Spring提供了5种scope分别是singleton、prototype、request、session、global session。
>
> 如果一个bean被声明为单例的时候，在处理多次请求的时候在spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候会先从缓存（map）里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。
>
> 但是对于原型（prototype）bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。

- 频繁创建实例对象会影响性能，使用单例模式保证只会创建一个对象，提高了性能
- 由于创建的实例对象少了，所以会减少JVM的垃圾回收
- 单例的bean除了第一次获取的时候需要创建，之后操作获取这个bean都是从缓存里获取，因此可以快速获取到bean

**由于多个请求共享一个bean实例，因此如果实例是有状态的话，在并发环境下线程不安全。**

>**什么是有状态对象？什么是无状态对象？**
> 有状态对象：有实例变量可以标志其对象所处的状态。（有实例变量的对象，有存储数据能力）- 白话：有属性的对象
> 无状态对象：无实例变量可以标志其对象所处的状态。（无实例变量的对象，无存储数据能力）- 白话：无属性的对象



### 为什么实现接口是jdk的动态代理，没有实现接口是cglib的动态代理







# Linux

### 如何查看日志中第n行的数据

- 使用vim查看日志，然后在编辑模式下输入对应的行号即可
- ``tail -n +行号 文件名 | head -n 1``
  - ``tail -n +3``表示从第三行开始查看数据
  - ``tail -n 3``表示查看最后3行数据
  - ``head -n 3``表示查看前面3行





# RabbitMQ

### 如何保证消息不丢失

> 丢失原因：
>
> - **生产者没有成功把消息发送到MQ：**因为网络传输不稳定，当生产者向MQ发送消息的过程中，MQ没有成功接收到消息，但是生产者以为MQ成功接收到消息，不会再次发送重复消息，导致消息丢失。
> - **MQ接收到消息之后消息丢失：**MQ接收到了消息，但是消息是保存在内存里的，如果此时消息没有被消费，MQ宕机，导致消息丢失。
> - **消费者弄丢了消息：**MQ将消息成功发送给了消费者，但是消费者还没执行完相应操作，服务挂掉了。由于MQ默认只要消费者消费了消息，就不会再发送消息，所以导致消息丢失。

- **生产者没有成功把消息发送到MQ:**开启``confirm``模式，生产者会给每个消息分配一个唯一的ID，如果消息成功写入到MQ，MQ就会给生产者回传一个ACK消息；如果MQ没能处理这个消息，会回传一个NACK的消息。
- **MQ接收到消息之后消息丢失：**开启MQ的持久化，当生产者把消息成功写入到MQ之后，MQ会把消息持久化到磁盘。结合上面的``confirm``机制，如果开启了消息的持久化，只有当消息成功持久化到磁盘之后，才会回调生产者的接口返回ACK消息。存入磁盘的消息不会丢失，就算MQ挂掉，重启之后，消息仍然存在。**队列持久化，消息持久化（springboot默认持久化），开启``confirm``机制**
- **消费者弄丢了消息：**关闭MQ的自动ACK，开启手动ACK。因为自动ACK是消费者收到消息后就确认。



### 如何防止重复消费

> 重复消费：正常情况下，消费者消费完消息后，会发送一个确认消息给消息队列，然后MQ将这条消息冲队列中删除。可能由于网络传输等故障，确认消息没有到达MQ，MQ会重新发送消息。
>
> 思路：保证消息的唯一性；保证消息的幂等性

- 如果是对数据库做insert操作，可以先查询一下数据库是否已经有记录，如果没有记录再操作。
- 使用redis，将消息id存入到redis中，比如set中。先查询redis是否有消息id，如果有则不进行操作
- 也可以使用redis的setnx命令，如果成功则说明消息第一次被消费；失败表示消息已经被消费过了



### rabbitmq的使用场景











# 项目

### 秒杀系统中rabbitmq主要是用来做什么？

- 首先是流量削封。对数据库修改库存的时候，由于mysql的读写能力较低，大量请求可能导致mysql服务宕机。用户下单成功之后，使用rabbitmq发送消息给消费者，然后消费者去操作数据库修改库存，将用户
- 第二个是异步，用户在下单成功之后，系统则给用户返回一个提示信息，不用等修改库存，增加订单等操作完成。



### 秒杀系统中不使用rabbitmq可以使用什么？

可以使用线程池，用户下单之后，将任务提交到线程池，异步的去数据库修改数据，但是这样如果并发量很大，会导致线程池的工作队列满了，然后丢弃一些任务。



### 为什么使用双重MD5加密

前端使用固定盐值通过MD5进行加密，保证用户密码在网络传输中处于加密状态，即使被截取也无法知道真正的密码，保证用户账户安全。

后端使用随机盐值对密码进行加密，进一步加强了用户密码的安全性。



### 使用什么策略进行接口限流

使用的是令牌桶算法对接口进行限流。

令牌桶算法以一定的速率生成令牌，每个请求进来的时候都需要去拿到令牌，只有拿到令牌的请求才能够被处理，而没有拿到令牌的请求则直接返回一些错误信息。

### 令牌桶算法和漏桶算法有什么区别

漏桶算法以恒定的速率处理请求，而不会去限制请求的访问速率，当请求的访问速率过快，超过了预先设定的值，那么超过的这些请求将直接被拒绝。

令牌桶算法以恒定的速率生成令牌，只有拿到令牌的请求才能够被处理，没有拿到令牌的请求会被直接拒绝。

**因此令牌桶可以看做是在请求的入口处限制速率，而漏桶是在请求的出口处限制速率。令牌桶还可以很好的应对突发传输：如果令牌桶的桶容量是500，并且是满的，那么如果来了500个请求，这500个请求都可以马上得到处理。而如果漏桶的桶容量是500，每秒处理50个请求，如果来了500个请求，虽然他们都可以得到处理，但由于处理速度固定，因此他们不能马上得到处理。**



### token过期了怎么办





### 项目中使用到了哪些Redsis的数据结构

使用到了string、set、hash。

- 使用string来存储验证码、token等信息。
- 因为set具有天然的去重性，所以将订单号和用户id存储在set中，防止多人重复下单。
- hash主要是用来存储一些对象。







### 如果用户在规定时间内没有付款成功怎么办

1. 使用定时任务：设置秒杀活动结束后30分钟的时候检查数据库，查看订单是否处于已支付状态，如果未支付，则删除订单，并且修改商品库存。
2. 使用rabbitmq的延迟队列：设置消息的ttl为30分钟，30分钟后，消费者消费到这条消息，然后去查询订单支付状态，如果未支付则删除订单，修改商品库存。





# 算法

### 二叉树的层次遍历

> 滴滴暑假实习一面 A





### 不同的二叉搜索树

> 滴滴暑假实习一面：没写出来，换了上面那道题





### 非递归的二叉树的前序遍历

> 滴滴暑假实习二面   A 







### 合并两个有序数组

> 滴滴暑假实习二面  A
>
> 如：{1,2,5,6，8}  {2,3,4,6，7，9，10} 合并成一个有序数组
>
> **拓展：对合并后的数组去重**







